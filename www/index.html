<!doctype html>
<html lang="fr">
<head>
<title>Color sequences viewer</title>
<meta charset="utf-8">

<!-- STYLES -->
<link rel="stylesheet"
	href="http://openlayers.org/en/v3.17.1/css/ol.css" type="text/css">
<style>
body,html {
	margin: 0;
	padding: 0;
	height: 100%;
}

#map {
	float: left;
	width: 50%;
	height: 100%;
	background-color: #C0C0C0;
}

#ThreeJS {
	float: right;
	width: 50%;
	height: 100%;
	background-color: #C0C0C0;
}

.wrap {
	width: 100%;
	height: 100%;
}
</style>
<!--  SCRIPTS -->
<!-- The palette-->
<script type="text/javascript" src="data/palette.json"></script>

<!-- Libraries-->
<script
	src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/1.1.1/chroma.min.js"></script>
<script src="js/gamut.js"></script>
<script
	src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r79/three.min.js"></script>
<script src="http://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script
	src='https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.5.1/dat.gui.min.js'></script>
<script src="http://openlayers.org/en/v3.17.1/build/ol.js"></script>
</head>
<body>
	<!-- CONTAINERS-->
	<div class="wrap">
		<!-- Three.js scene-->
		<div id="ThreeJS"></div>
		<!--  Leaflet Map -->
		<div id="map"></div>
	</div>

	<!-- Application scripts-->
	<script>
		window.onload = function() {
			sldBody = readTextFile("data/sld.sld");
			var layer = new ol.layer.Image(
					{
						source : new ol.source.ImageWMS(
								{
									url : 'http://localhost:8080/geoserver/wms',
									params : {
										'LAYERS' : 'cite:Population_commune_1999_2010_GIP_region',
										'SLD_BODY' : sldBody,
									},
									serverType : 'geoserver'
								})
					});

			var map = new ol.Map({
				layers : [ layer ],
				target : 'map',
				view : new ol.View({
					center : [ -350000, 6100777 ],
					zoom : 8.0
				})
			});

		}
		var gamut, gui, container, scene, camera, renderer, controls;

		/****************************/
		/*
		 * INIT THE SCENE 
		 */
		bscene();

		/*
		 *CREATES THE GAMUT OBJECT
		 */
		gamut = new Gamut();
		scene.add(gamut.shape);

		/*
		 * CREATE THE PALETTE OBJECT AND ADD IT TO THE SCENE
		 */
		var ptex = new THREE.TextureLoader().load('images/circle.png');
		palette = new Palette();
		palette.addToScene();

		/*
		 *BUILDS THE INTERFACE
		 */
		binterface();

		/**
		 * RENDER
		 **/
		animate();

		/****************************/

		function Gamut() {
			this.detail = 5;
			this.name = 'sRGBGamut';
			this.view = THREE.BackSide;
			this.shape = null;
			this.update_gamut = function(detail) {
				var gamut_attributes = Gamut3D_sRGB_LAB(detail);
				var geometry = new THREE.BufferGeometry();
				geometry.addAttribute('position', new THREE.BufferAttribute(
						gamut_attributes.position.array, 3));
				geometry.addAttribute('color', new THREE.BufferAttribute(
						gamut_attributes.color.array, 3));
				geometry.computeBoundingBox();
				geometry.computeBoundingSphere();
				geometry.computeVertexNormals();
				geometry.computeFaceNormals();
				this.shape.geometry = geometry;
			};
			this.build_gamut = function(detail) {
				this.shape = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1),
						new THREE.MeshLambertMaterial({
							color : 0xFFFFFF,
							vertexColors : THREE.VertexColors,
							transparent : true,
							depthTest : false,
							opacity : 1,
							side : THREE.BackSide
						}))
				this.shape.name = name;
				this.shape.material.needsUpdate = true;
				this.update_gamut(detail);
			};

			//Init!
			this.build_gamut(this.detail);
		}

		function Palette() {
			var c, sprites = [], pal = JSON.parse(pdata);
			for (i = 0; i < pal.length; i++) {
				c = chroma(pal[i]);
				var circle = new THREE.SpriteMaterial({
					map : ptex,
					color : c.hex()
				});
				var sprite = new THREE.Sprite(circle);
				var clab = c.lab();
				sprite.position.set(clab[0], clab[1], clab[2]);
				sprite.scale.set(6, 6, 1.0); // imageWidth, imageHeight
				sprites.push(sprite);
			}

			this.addToScene = function() {
				for (s in sprites) {
					scene.add(sprites[s]);
				}
			}
		}

		// Sets up the scene
		function bscene() {

			// Create the scene and set the scene size.
			container = document.getElementById('ThreeJS');
			scene = new THREE.Scene();

			var SCREEN_WIDTH = container.clientWidth; //window.innerWidth
			var SCREEN_HEIGHT = container.clientHeight;
			var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 10000;

			// Create a camera, zoom it out from the model a bit, and add it to the scene.
			camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
			scene.add(camera);
			camera.position.set(250, -200, 0);

			// Create a renderer and add it to the DOM.
			renderer = new THREE.WebGLRenderer({
				antialias : true
			});
			renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

			container.appendChild(renderer.domElement);

			// Camera control
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.target = new THREE.Vector3(50, 0, 0); //Look at the neutral grey (no specific illuimant here)

			//Debug axis
			scene.add(new THREE.AxisHelper(30));
			// Create an event listener that resizes the renderer with the browser window.
			window.addEventListener('resize', function() {
				var WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
				renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
				camera.aspect = SCREEN_WIDTH / SCREEN_HEIGHT;
				camera.updateProjectionMatrix();
			});

			// Set the background color of the scene to neutral grey.
			renderer.setClearColor(0xC0C0C0, 1);

			// Create a light, set its position, and add it to the scene.
			var light = new THREE.AmbientLight(0xffffff);
			scene.add(light);

		}

		function binterface() {
			gui = new dat.GUI();
			var gf = gui.addFolder('sRGB Gamut');
			gf.open();
			var lodController = gf.add(gamut, "detail", 1, 50);
			lodController.step(1);
			lodController.onChange(function(detailValue) {
				gamut.update_gamut(detailValue)
			});

			gf.add(gamut.shape.material, "opacity", 0, 1).onChange(
					function(opacityValue) {
						gamut.shape.material.opacity = opacityValue;
					});

			gf.add(gamut.shape.material, "wireframe", true, false).onChange(
					function(wireframeValue) {
						gamut.shape.material.wireframe = wireframeValue;
					});

			gf.add(gamut, "view", [ 'Full', 'Interior' ]).onChange(
					function(viewValue) {
						if (viewValue == "Full") {

							gamut.view = THREE.DoubleSide;
							gamut.shape.material.side = THREE.DoubleSide;
							gamut.shape.material.depthTest = true; //Re-enable the depth test to avoid weird rendering in DoubleSide mode.
						}
						if (viewValue == "Interior") {
							gamut.view = THREE.BackSide;
							gamut.shape.material.side = THREE.BackSide;
							gamut.shape.material.depthTest = false;
						}
					});
		}

		function animate() {
			requestAnimationFrame(animate);
			renderer.render(scene, camera);
			controls.update();
		}

		function readTextFile(file) {
			var rawFile = new XMLHttpRequest(), allText;
			rawFile.open("GET", file, false);
			rawFile.onreadystatechange = function() {
				if (rawFile.readyState === 4) {
					if (rawFile.status === 200 || rawFile.status == 0) {
						allText = rawFile.responseText;
					}
				}
			}
			rawFile.send(null);
			return allText;
		}
	</script>
</body>
</html>
